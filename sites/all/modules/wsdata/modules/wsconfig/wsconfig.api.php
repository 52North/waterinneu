<?php

/**
 * @file
 * Describe the file
 */

/**
 * Register as a connector module
 *
 * @return array
 *  Returns an array definining the function callbacks for all supported
 *  CRUD operations
 */
function hook_wsconfig_connector_info() {
  // Array of functions to call for each CRUD task
  
  // Since modules can create multiple connectors, add a unique ID to define
  // each set of CRUD operations. Typically, this can be your module name if
  // you only implement one connector. Otherwise, adding mymodule_rest or
  // mymodule_soap is another appropriate naming convention
  
  // The array should contain at minimum one CRUD operation and the human
  // readable name of your connector. Do NOT wrap the name in the t() function
  // since it will be translated automatically later on.
  
  // The keys in the array must match the following:
  return array(
    'myconnectorid' => array(
      'name' => 'Display Name for MyConnector',
      'class' => 'myprocessorclassname',
    ),
  );
}

/**
 * Define a list of processors your module implements
 *
 * Processors are used to parse the data coming back from web service calls
 * into the proper format for storing data in fields. They are responsible
 * for creating the structure arrays for all supported entities/fields.
 *
 * This hook allows modules to register classes which implement the WsData
 * class and allows the user to select the appropriate processor through
 * the UI.
 *
 * @return array
 *  Returns a structure array defining your processor(s)
 *
 *  Since the processor classes may implement fields and/or entities, the
 *  hook requires implementations to register all the supported objects.
 *
 *  Ex: array('MyModuleWsDataJson' => array('text' => 'JSON Parser for My Module'));
 */
function hook_wsconfig_processor_info() {
  return array(
    'myprocessorclassname' => array(
      'fields' => array(
        'machinetype' => 'Display name for MyProcessor',
      ),
      'entities' => array(
        'machinetype' => 'Display name for MyProcessor',
      ),
    ),
  );
}

/**
 * Sample implementation of WsData
 *
 * This class is responsible for all data functions on your web service data.
 * It parses the data from the service call and exports it in the appropriate
 * format. For example, you can have a processor for json data and have it
 * output the data in formatted arrays to be used with fields.
 */
class SampleProcessor extends WsData {

  /**
   * WsData provides a default getData implementation. This function must
   * return a properly structured field array (including language, array of
   * values, field names, etc...).
   *
   * The default function returns a structured array as follows:
   *  Ex: array(LANGUAGE_NONE => array(0 => array('value' => 'somevalue')));
   *
   * It is the same structure as generated by the default fields in Drupal
   * core.
   */
  function getData($key) {
    // Your code here if need be
  }
  
  /**
   * Parser function
   *
   * Each instance of WsData must include an implementation of parse. This
   * is the function which takes in data from the web service and converts
   * it into data which Drupal can understand and use in fields.
   *
   * The parsed data must be converted into an array which follows the same
   * data hierarchy as your source data to work with the default getData()
   * method.
   *
   * For example, this function may accept an XML string and return an array
   * of data representing that string.
   *
   * @param $data
   *  Data to be parsed
   * @return array|boolean
   *  Return the parsed data, FALSE otherwise.
   */
  function parse($data) {
    // Do something
  }
  
  /**
   * Accepted data formats
   *
   * Tells the WsConnector the type of data the parser can accept as input.
   * Some web services offer data in a variety of formats (ex: json, xml).
   * This function tells the WsConnector instance what type of data to request
   * from the service.
   *
   * At the same time, if the WsConnector doesn't support the sepcified data
   * format, the service call is skipped and a warning is logged.
   *
   * You can define any kind of data format in the accepts array as long as
   * the WsConnector knows how to interpret it. By default, "xml" and "json"
   * are supported by the base class of WsConnector.
   *
   * @return array
   *  Returns an array of strings.
   */
  function accepts() {
    return array('xml', 'json');
  }
}

/**
 * Sample implementation of WsConnector
 *
 * This class is responsible for handling the web service requests for all
 * CRUD operations. The class can contain all functionality for making a given
 * request (i.e. http request) or is can wrap another set of functions into
 * it (ex: restclient).
 */
class SampleConnector extends WsConnector {
  // @todo
}